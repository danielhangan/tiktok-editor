<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TikTok Video Editor</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 1400px; margin: 0 auto; }
    h1 { text-align: center; margin-bottom: 30px; font-size: 2.5rem; }
    h1 span { background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    
    .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 30px; }
    @media (max-width: 1200px) { .grid { grid-template-columns: 1fr; } }
    
    .card {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 20px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .card h2 { margin-bottom: 15px; font-size: 1.3rem; display: flex; align-items: center; gap: 10px; }
    .card h2 .icon { font-size: 1.5rem; }
    
    .dropzone {
      border: 2px dashed rgba(255,255,255,0.3);
      border-radius: 12px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 15px;
    }
    .dropzone:hover, .dropzone.dragover {
      border-color: #48dbfb;
      background: rgba(72, 219, 251, 0.1);
    }
    .dropzone input { display: none; }
    .dropzone p { color: rgba(255,255,255,0.6); }
    
    .file-list { max-height: 200px; overflow-y: auto; }
    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      margin-bottom: 8px;
      font-size: 0.9rem;
    }
    .file-item .name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .file-item button {
      background: #ff6b6b;
      border: none;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 14px;
    }
    
    textarea {
      width: 100%;
      height: 200px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #fff;
      padding: 12px;
      font-family: inherit;
      resize: vertical;
    }
    textarea::placeholder { color: rgba(255,255,255,0.4); }
    
    .btn {
      background: linear-gradient(90deg, #ff6b6b, #feca57);
      border: none;
      color: #1a1a2e;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: 1rem;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(255,107,107,0.4); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .btn.secondary { background: rgba(255,255,255,0.1); color: #fff; }
    
    .generate-section {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 30px;
      text-align: center;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .generate-section h2 { margin-bottom: 20px; }
    
    .stats {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-bottom: 20px;
    }
    .stat { text-align: center; }
    .stat .number { font-size: 2rem; font-weight: bold; color: #48dbfb; }
    .stat .label { color: rgba(255,255,255,0.6); font-size: 0.9rem; }
    
    .combo-config {
      display: flex;
      gap: 15px;
      justify-content: center;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .combo-config label { color: rgba(255,255,255,0.7); }
    .combo-config input, .combo-config select {
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
      padding: 8px 12px;
    }
    
    .progress-bar {
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
      overflow: hidden;
      margin: 20px 0;
    }
    .progress-bar .fill {
      height: 100%;
      background: linear-gradient(90deg, #48dbfb, #feca57);
      transition: width 0.3s;
    }
    
    .output-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    .output-item {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      overflow: hidden;
    }
    .output-item video { width: 100%; display: block; }
    .output-item .info { padding: 10px; font-size: 0.85rem; }
    .output-item .info a { color: #48dbfb; text-decoration: none; }
    
    .hidden { display: none; }
    
    #status { margin-top: 15px; color: rgba(255,255,255,0.7); }
  </style>
</head>
<body>
  <div class="container">
    <h1><span>üé¨ TikTok Video Editor</span></h1>
    
    <div class="grid">
      <!-- Reactions -->
      <div class="card">
        <h2><span class="icon">üòÆ</span> Face Reactions</h2>
        <div class="dropzone" id="reactions-dropzone">
          <input type="file" id="reactions-input" multiple accept="video/*">
          <p>Drop reaction videos here<br>or click to upload</p>
        </div>
        <div class="file-list" id="reactions-list"></div>
      </div>
      
      <!-- Demos -->
      <div class="card">
        <h2><span class="icon">üì±</span> App Demos</h2>
        <div class="dropzone" id="demos-dropzone">
          <input type="file" id="demos-input" multiple accept="video/*">
          <p>Drop demo videos here<br>or click to upload</p>
        </div>
        <div class="file-list" id="demos-list"></div>
      </div>
      
      <!-- Hooks -->
      <div class="card">
        <h2><span class="icon">üìù</span> Text Hooks</h2>
        <textarea id="hooks-input" placeholder="Enter text hooks, one per line..."></textarea>
        <button class="btn secondary" onclick="saveHooks()" style="margin-top:10px;width:100%">Save Hooks</button>
      </div>
    </div>
    
    <!-- Generate Section -->
    <div class="generate-section">
      <h2>üöÄ Generate Videos</h2>
      
      <div class="stats">
        <div class="stat">
          <div class="number" id="stat-reactions">0</div>
          <div class="label">Reactions</div>
        </div>
        <div class="stat">
          <div class="number" id="stat-demos">0</div>
          <div class="label">Demos</div>
        </div>
        <div class="stat">
          <div class="number" id="stat-hooks">0</div>
          <div class="label">Hooks</div>
        </div>
      </div>
      
      <div class="combo-config">
        <label>Videos to generate:</label>
        <input type="number" id="video-count" value="6" min="1" max="100">
        <label>Mode:</label>
        <select id="combo-mode">
          <option value="random">Random combinations</option>
          <option value="sequential">Sequential (match by index)</option>
        </select>
      </div>
      
      <button class="btn" id="generate-btn" onclick="generateVideos()">
        Generate TikTok Videos
      </button>
      
      <div class="progress-bar hidden" id="progress-bar">
        <div class="fill" id="progress-fill" style="width:0%"></div>
      </div>
      
      <div id="status"></div>
    </div>
    
    <!-- Outputs -->
    <div class="card" style="margin-top:30px">
      <h2><span class="icon">üé•</span> Generated Videos</h2>
      <div class="output-grid" id="outputs-grid"></div>
    </div>
  </div>

  <script>
    const API = '';
    let state = { reactions: [], demos: [], hooks: [] };
    
    // Initialize
    async function init() {
      await loadFiles('reactions');
      await loadFiles('demos');
      await loadHooks();
      await loadOutputs();
    }
    
    // Load files from server
    async function loadFiles(type) {
      const res = await fetch(`${API}/api/files/${type}`);
      state[type] = await res.json();
      renderFiles(type);
      updateStats();
    }
    
    // Load hooks
    async function loadHooks() {
      const res = await fetch(`${API}/api/hooks`);
      state.hooks = await res.json();
      document.getElementById('hooks-input').value = state.hooks.join('\n');
      updateStats();
    }
    
    // Save hooks
    async function saveHooks() {
      const text = document.getElementById('hooks-input').value;
      state.hooks = text.split('\n').filter(h => h.trim());
      await fetch(`${API}/api/hooks`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ hooks: state.hooks })
      });
      updateStats();
      showStatus('Hooks saved!');
    }
    
    // Render file list
    function renderFiles(type) {
      const list = document.getElementById(`${type}-list`);
      list.innerHTML = state[type].map(f => `
        <div class="file-item">
          <span class="name">${f.originalName}</span>
          <button onclick="deleteFile('${type}', '${f.id}')">&times;</button>
        </div>
      `).join('');
    }
    
    // Delete file
    async function deleteFile(type, id) {
      await fetch(`${API}/api/files/${type}/${id}`, { method: 'DELETE' });
      await loadFiles(type);
    }
    
    // Update stats
    function updateStats() {
      document.getElementById('stat-reactions').textContent = state.reactions.length;
      document.getElementById('stat-demos').textContent = state.demos.length;
      document.getElementById('stat-hooks').textContent = state.hooks.length;
    }
    
    // Setup dropzones
    ['reactions', 'demos'].forEach(type => {
      const dropzone = document.getElementById(`${type}-dropzone`);
      const input = document.getElementById(`${type}-input`);
      
      dropzone.onclick = () => input.click();
      
      dropzone.ondragover = (e) => { e.preventDefault(); dropzone.classList.add('dragover'); };
      dropzone.ondragleave = () => dropzone.classList.remove('dragover');
      dropzone.ondrop = (e) => {
        e.preventDefault();
        dropzone.classList.remove('dragover');
        uploadFiles(type, e.dataTransfer.files);
      };
      
      input.onchange = () => uploadFiles(type, input.files);
    });
    
    // Upload files
    async function uploadFiles(type, files) {
      const formData = new FormData();
      Array.from(files).forEach(f => formData.append('files', f));
      
      showStatus(`Uploading ${files.length} file(s)...`);
      
      const res = await fetch(`${API}/api/upload/${type}`, {
        method: 'POST',
        body: formData
      });
      
      if (res.ok) {
        await loadFiles(type);
        showStatus('Upload complete!');
      } else {
        showStatus('Upload failed!');
      }
    }
    
    // Generate videos
    async function generateVideos() {
      const count = parseInt(document.getElementById('video-count').value);
      const mode = document.getElementById('combo-mode').value;
      
      if (!state.reactions.length || !state.demos.length) {
        showStatus('Please upload reactions and demos first!');
        return;
      }
      
      // Build combinations
      const combinations = [];
      for (let i = 0; i < count; i++) {
        let reactionIdx, demoIdx, hookIdx;
        
        if (mode === 'sequential') {
          reactionIdx = i % state.reactions.length;
          demoIdx = i % state.demos.length;
          hookIdx = i % (state.hooks.length || 1);
        } else {
          reactionIdx = Math.floor(Math.random() * state.reactions.length);
          demoIdx = Math.floor(Math.random() * state.demos.length);
          hookIdx = Math.floor(Math.random() * (state.hooks.length || 1));
        }
        
        combinations.push({
          reactionId: state.reactions[reactionIdx].id,
          demoId: state.demos[demoIdx].id,
          hookIndex: hookIdx
        });
      }
      
      document.getElementById('generate-btn').disabled = true;
      document.getElementById('progress-bar').classList.remove('hidden');
      showStatus('Starting video generation...');
      
      const res = await fetch(`${API}/api/generate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ combinations })
      });
      
      const { jobId } = await res.json();
      pollJob(jobId);
    }
    
    // Poll job status
    async function pollJob(jobId) {
      const res = await fetch(`${API}/api/jobs/${jobId}`);
      const job = await res.json();
      
      const pct = job.total ? (job.completed / job.total * 100) : 0;
      document.getElementById('progress-fill').style.width = pct + '%';
      showStatus(`Processing: ${job.completed}/${job.total} videos`);
      
      if (job.status === 'complete') {
        document.getElementById('generate-btn').disabled = false;
        showStatus(`Done! Created ${job.outputs.length} videos`);
        await loadOutputs();
      } else {
        setTimeout(() => pollJob(jobId), 2000);
      }
    }
    
    // Load outputs
    async function loadOutputs() {
      const res = await fetch(`${API}/api/outputs`);
      const outputs = await res.json();
      
      const grid = document.getElementById('outputs-grid');
      grid.innerHTML = outputs.map(o => `
        <div class="output-item">
          <video controls src="${o.url}"></video>
          <div class="info">
            <div>${o.filename}</div>
            <div>${(o.size / 1024 / 1024).toFixed(1)} MB</div>
            <a href="${o.url}" download>Download</a>
          </div>
        </div>
      `).join('');
    }
    
    // Show status
    function showStatus(msg) {
      document.getElementById('status').textContent = msg;
    }
    
    init();
  </script>
</body>
</html>
